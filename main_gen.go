// Code generated by argsgen.
// DO NOT EDIT!
package main

import (
    "errors"
    "flag"
    "fmt"
    "os"
)

func (o *options) flagSet() *flag.FlagSet {
    flagSet := flag.NewFlagSet(os.Args[0], flag.ExitOnError)
    flagSet.StringVar(&o.interval, "interval", o.interval, "updater internal")
    flagSet.StringVar(&o.username, "username", o.username, "NoIP username")
    flagSet.StringVar(&o.password, "password", o.password, "NoIP password")
    flagSet.StringVar(&o.dns, "dns", o.dns, "NoIP DNS")
    return flagSet
}

// Parse parses the arguments in os.Args
func (o *options) Parse() error {
    flagSet := o.flagSet()
    args := os.Args[1:]
    for len(args) > 0 {
        if err := flagSet.Parse(args); err != nil {
            return err
        }

        if remaining := flagSet.NArg(); remaining > 0 {
            posIndex := len(args) - remaining
            args = args[posIndex+1:]
            continue
        }
        break
    }

    if o.username == "" {
        return errors.New("argument 'username' is required")
    }
    if o.password == "" {
        return errors.New("argument 'password' is required")
    }
    if o.dns == "" {
        return errors.New("argument 'dns' is required")
    }
    return nil
}

// MustParse parses the arguments in os.Args or exists on error
func (o *options) MustParse() {
    if err := o.Parse(); err != nil {
        o.flagSet().PrintDefaults()
		fmt.Fprintln(os.Stderr)
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
    }
}

func (o *IPResponse) flagSet() *flag.FlagSet {
    flagSet := flag.NewFlagSet(os.Args[0], flag.ExitOnError)
    flagSet.StringVar(&o.Query, "Query", o.Query, "")
    return flagSet
}

// Parse parses the arguments in os.Args
func (o *IPResponse) Parse() error {
    flagSet := o.flagSet()
    args := os.Args[1:]
    for len(args) > 0 {
        if err := flagSet.Parse(args); err != nil {
            return err
        }

        if remaining := flagSet.NArg(); remaining > 0 {
            posIndex := len(args) - remaining
            args = args[posIndex+1:]
            continue
        }
        break
    }

    return nil
}

// MustParse parses the arguments in os.Args or exists on error
func (o *IPResponse) MustParse() {
    if err := o.Parse(); err != nil {
        o.flagSet().PrintDefaults()
		fmt.Fprintln(os.Stderr)
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
    }
}
